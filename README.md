# rust-raylib-sys
## Automated rust bindings for raylib

### What is this?
Primarily this is a learning exercise for myself and something for me to refer back to in the future.
This is the MVP required to unsafely call into a c lib (raylib) from rust. The bindings are automatically generated by bindgen and use raylib's cmake config for building raylib itself (see `build.rs`).

### Why use it?
You probably don't want to use this, but maybe you do if:
* you want automated unsafe bindings without having to configure the build yourself
* you're happy to add your target system's config to `build.rs`
* you want to quickly generate bindings to the latest version of raylib and safely wrap the part of the api that you intend to use

### Consider Instead
* https://github.com/deltaphc/raylib-rs (as linked by the raylib home page)

### Thanks and References
* `build.rs` reference https://github.com/deltaphc/raylib-rs 
* `build.rs` reference https://github.com/Rust-SDL2/rust-sdl2
* overview of bindgen ffi https://rust-lang.github.io/rust-bindgen/
* overview of bindgen ffi with c source code https://medium.com/dwelo-r-d/using-c-libraries-in-rust-13961948c72a
* https://docs.rs/cmake/latest/cmake/
* https://doc.rust-lang.org/nomicon/ffi.html

## Example usage - Opening a blank window
```rust
use rust_raylib_sys as raylib;

fn main() {
    const SCREEN_WIDTH: i32 = 640;
    const SCREEN_HEIGHT: i32 = 480;

    unsafe {
        let title = std::ffi::CString::new("raylib rust").expect("CString failed");
        raylib::InitWindow(SCREEN_WIDTH, SCREEN_HEIGHT, title.as_ptr());
        raylib::SetTargetFPS(60);

        while !raylib::WindowShouldClose() {
            raylib::BeginDrawing();
            raylib::ClearBackground(raylib::ColorFromHSV(0f32, 0f32, 0f32));
            raylib::EndDrawing();
        }
        raylib::CloseWindow();
    }
}
```

## Binding Process
* Make a new rust lib `cargo new --lib`
* Add the c sources in their own directory
* Create a c header file (`wrapper.h`) that imports all source headers to be bound
* Run `gen_bindings.sh`
* `include!` the generated bindings in lib.rs
* Configure `build.rs` by adding the target os and cpu (this was frustrating on an M1 Mac which was building for x86_64 but trying to link with arm64, `cmake_cfg.define("CMAKE_OSX_ARCHITECTURES", "arm64")` solves this)
* `println!("cargo:rustc-link-search=native={}/lib", dst.display())` is what finds the built c lib
* Create a rust binary crate with the above example "open a window" code and run (`cargo run`)